diff --git a/src/response_transport.h b/src/response_transport.h
index 387ba01..f899e65 100644
--- a/src/response_transport.h
+++ b/src/response_transport.h
@@ -21,7 +21,7 @@
 #include "response_exception.h"
 
 void add_tally_contribution(Photon& phtn, Tally*& tally, 
-			    Sphere_Response*& resp, uint32_t cell_id, double next_dt ) {
+			    Sphere_Response*& resp, uint32_t cell_id, double dt ) {
   using Constants::c;
 
   try {
@@ -30,7 +30,7 @@ void add_tally_contribution(Photon& phtn, Tally*& tally,
       double cell_response = resp->get_response(cell_id);
       // calculate the contribution to the tally 
       double tally_contr = phtn.get_E() * 
-          exp(-(cell_response + 1 / (c * next_dt)) * dist_to_tally);   
+          exp(-(cell_response + 1.0 / (c * dt)) * dist_to_tally);   
       // Add the contribution to the tally
       if(tally_contr > 0) {
          tally->add_response_weight(abs(tally_contr));	
@@ -38,13 +38,13 @@ void add_tally_contribution(Photon& phtn, Tally*& tally,
       //cout << "\t\t\t\tEnergy: " << phtn.get_E() << "\tContr: " << tally_contr << endl;
   } catch(Response_Exception& e) {
       resp->increase_response();
-      add_tally_contribution(phtn, tally, resp, cell_id, next_dt);
+      add_tally_contribution(phtn, tally, resp, cell_id, dt);
   }
 
 }
 
 Constants::event_type resp_transport_photon(Photon &phtn, const Mesh &mesh, RNG *rng,
-                                       double &next_dt, double &exit_E,
+                                       double &next_dt, double &dt, double &exit_E,
                                        double &census_E,
                                        std::vector<double> &rank_abs_E,
                                        std::vector<double> &rank_track_E,
@@ -79,7 +79,7 @@ Constants::event_type resp_transport_photon(Photon &phtn, const Mesh &mesh, RNG
   bool active = true;
 
   // Add the response tally contribution
-  add_tally_contribution(phtn, tally, resp, cell_id, next_dt);
+  add_tally_contribution(phtn, tally, resp, cell_id, dt);
   tally->add_response_hit();
   
   // transport this photon
@@ -143,7 +143,7 @@ Constants::event_type resp_transport_photon(Photon &phtn, const Mesh &mesh, RNG
            phtn.set_group(sample_emission_group(rng, cell));
 
 	// Add the response tally contribution
-         add_tally_contribution(phtn, tally, resp, cell_id, next_dt);
+         add_tally_contribution(phtn, tally, resp, cell_id, dt);
          tally->add_response_hit();
       }
       // EVENT TYPE: BOUNDARY CROSS
@@ -193,7 +193,7 @@ std::vector<Photon> response_transport(Source &source, const Mesh &mesh,
   double census_E = 0.0;
   double exit_E = 0.0;
   double next_dt = imc_state.get_next_dt(); //! Set for census photons
-  double dt = imc_state.get_next_dt();      //! For making current photons
+  double dt = imc_state.get_dt();      //! For making current photons
 
   RNG *rng = imc_state.get_rng();
   rng->set_seed(rand(), 0); 
@@ -223,7 +223,7 @@ std::vector<Photon> response_transport(Source &source, const Mesh &mesh,
     phtn = source.get_photon(rng, dt);
     n_local_sourced++;
 
-    event = resp_transport_photon(phtn, mesh, rng, next_dt, exit_E,
+    event = resp_transport_photon(phtn, mesh, rng, next_dt, dt, exit_E,
                              census_E, rank_abs_E, rank_track_E, tally, resp);
 
     switch (event) {
diff --git a/src/sphere_response.h b/src/sphere_response.h
index 2c90119..afc1193 100644
--- a/src/sphere_response.h
+++ b/src/sphere_response.h
@@ -55,6 +55,7 @@ public:
 
 	cell_total_sigma_dist.assign(n_cell, 0.0);
         cell_total_dist.assign(n_cell, 0.0);
+        num_respon_source.assign(n_cell, 0);
 
         uint32_t index;
 	double pos[3];
@@ -62,11 +63,13 @@ public:
 	Photon phtn;
 
 	for(int k = 0; k < n_particles; k++) {
-	    index = (uint32_t)(rng->generate_random_number() * n_particles);
+	    index = (uint32_t)(rng->generate_random_number() * phtn_deck_size);
 	    pos[0] = start_x[index];
 	    pos[1] = start_y[index];
 	    pos[2] = start_z[index];	
 	    cell_id = start_cell_id[index];    
+        //std::cout<<cell_id<<std::endl;
+        num_respon_source[cell_id]++;
 	    
 	    create_photon(phtn, pos, cell_id);
 	    move_photon(phtn); 
@@ -83,7 +86,7 @@ public:
         uint32_t cell_id;
 	Photon phtn;
 
-	for(int k = 0; k < n_particles*5; k++) {
+	for(int k = 0; k < n_particles; k++) {
 	    index = (uint32_t)(rng->generate_random_number() * phtn_deck_size);
 	    pos[0] = start_x[index];
 	    pos[1] = start_y[index];
@@ -104,15 +107,25 @@ public:
 	return resp; 
     }
 
+    double get_dist(uint32_t cell_id) const { return cell_total_dist[cell_id]; }
+    double get_n_sourced(uint32_t cell_id) const { return num_respon_source[cell_id]; }
+
     void reset_response() { response_set = false; }
 
     void create_photon(Photon& phtn, double pos[3], uint32_t cell_id) {
-	double angle[3];
+	    double angle[3];
         get_uniform_angle(pos, angle);
+        /*
+        std::cout<<"o2[0] "<<angle[0]<<" ";
+        std::cout<<"o2[1] "<<angle[1]<<" ";
+        std::cout<<"o2[1] "<<angle[2]<<" ";
+        std::cout<<"2normal "<<sqrt(angle[0]*angle[0]+angle[1]*angle[1]+angle[2]*angle[2])<<" ";
+        std::cout<<std::endl;
+        */
 
         // Set photon values
         phtn.set_total_dist(0.0);
-	phtn.set_total_sigma_dist(0.0);
+	    phtn.set_total_sigma_dist(0.0);
         phtn.set_position(pos);
         phtn.set_angle(angle);
         phtn.set_cell(cell_id);
@@ -120,26 +133,59 @@ public:
     }
 
     void get_uniform_angle(double pos[3], double angle[3]) {
-	double r = sqrt(pow(pos[0]-tally_z,2)+pow(pos[1]-tally_y,2)+pow(pos[2]-tally_z,2));
-        double mu = (pos[2] - tally_z) / r; 
-        double theta = acos(mu);
-	double phi = atan((pos[1]-tally_y) / (pos[0]-tally_x));
-
         // Cosine-distribution for angle
-        double mu_r = sqrt(rng->generate_random_number());
-        double phi_r = 2 * Constants::pi * rng->generate_random_number();
-        double mu_theta = cos(phi_r) * sqrt(1 - pow(mu,2));
-        double mu_phi = sin(phi_r) * sqrt(1 - pow(mu_r,2));
-       
-        double mu_x = sin(theta)*cos(phi)*mu_r + cos(theta)*cos(phi)*mu_theta
-        	      - sin(phi)*mu_phi;
-        double mu_y = sin(theta)*sin(phi)*mu_r + cos(theta)*sin(phi)*mu_theta
-        	      + cos(phi)*mu_phi;
-        double mu_z = cos(theta)*mu_r - sin(theta)*mu_theta;
+        double costheta = sqrt(rng->generate_random_number());
+        double phi = 2.0 * Constants::pi * rng->generate_random_number();
+        
+        // calculate the inward normal.
+	    double r = sqrt(pow(tally_x-pos[0],2)+pow(tally_y-pos[1],2)+pow(tally_z-pos[2],2));
+        double x_hat = (tally_x - pos[0]) / r;
+	    double y_hat = (tally_y - pos[1]) / r;
+	    double z_hat = (tally_z - pos[2]) / r;
        
-        angle[0] = mu_x;
-	angle[1] = mu_y;
-	angle[2] = mu_z;
+        // helpful terms
+        double sintheta = sqrt(1.0-costheta*costheta);
+        double factor = sqrt(fabs(1.0-z_hat*z_hat));
+        double cosphi = cos(phi);
+        double sinphi = sin(phi);
+        double sintcosp = sintheta * cosphi;
+        double sintsinp = sintheta * sinphi;
+        double f_inv = 1.0/factor;
+        double stcpDf = sintcosp*f_inv;
+        double stspDf = sintsinp*f_inv;
+
+
+        // scatter through the random angle
+        if(factor<1.e-6){
+            angle[0] =  sintcosp;
+            angle[1] =  sintsinp;
+            angle[2] =  ((z_hat<0)? -1.0 :1.0 )*costheta;
+        } else {
+        angle[0] = x_hat*costheta + z_hat*x_hat*stcpDf - y_hat*stspDf;
+        angle[1] = y_hat*costheta + z_hat*y_hat*stcpDf + x_hat*stspDf;
+        angle[2] = z_hat*costheta - factor*sintcosp;
+        }
+
+        double norm=sqrt(angle[0]*angle[0]+angle[1]*angle[1]+angle[2]*angle[2]);
+        angle[0] /= norm;
+        angle[1] /= norm;
+        angle[2] /= norm;
+
+        // just set the direction in the outward normal produces the analytic result
+        /*
+        angle[0] = -(tally_x - pos[0]) / r;
+	    angle[1] = -(tally_y - pos[1]) / r;
+	    angle[2] = -(tally_z - pos[2]) / r;
+        std::cout<<"o[0] "<<angle[0]<<" ";
+        std::cout<<"o[1] "<<angle[1]<<" ";
+        std::cout<<"o[1] "<<angle[2]<<" ";
+        std::cout<<"normal "<<sqrt(angle[0]*angle[0]+angle[1]*angle[1]+angle[2]*angle[2])<<" ";
+        std::cout<<"p[0] "<<pos[0]<<" ";
+        std::cout<<"p[1] "<<pos[1]<<" ";
+        std::cout<<"p[2] "<<pos[2]<<" ";
+        std::cout<<"radius "<<sqrt(pos[0]*pos[0]+pos[1]*pos[1]+pos[2]*pos[2])<<" ";
+        std::cout<<std::endl;
+        */
     }
 
     void get_start_pos(double pos[3]) {
@@ -147,9 +193,17 @@ public:
         double mu = 1 - 2 * rng->generate_random_number();
         double theta = acos(mu);
         
-	pos[0] = tally_x + tally_r*(cos(phi)*sqrt((1-pow(mu,2))));
-	pos[1] = tally_y + tally_r*(sin(phi)*sqrt(1-pow(mu,2)));
+	    pos[0] = tally_x + tally_r*(cos(phi)*sqrt((1-pow(mu,2))));
+	    pos[1] = tally_y + tally_r*(sin(phi)*sqrt(1-pow(mu,2)));
         pos[2] = tally_z + tally_r*mu;
+        /*
+        std::cout<<"p[0] "<<pos[0]<<" ";
+        std::cout<<"p[1] "<<pos[1]<<" ";
+        std::cout<<"p[2] "<<pos[2]<<" ";
+        std::cout<<"radius "<<sqrt(pos[0]*pos[0]+pos[1]*pos[1]+pos[2]*pos[2])<<" ";
+        std::cout<<std::endl;
+        */
+
     }
 
     void print_response() {
@@ -194,7 +248,7 @@ private:
  	start_z.resize(phtn_deck_size);
 	start_cell_id.resize(phtn_deck_size);
 
-        double pos[3];
+   double pos[3];
 
 	for(uint32_t k = 0; k < phtn_deck_size; k++) {
 	    get_start_pos(pos);
@@ -208,6 +262,7 @@ private:
 	//Generate the variables to hold the resp info
 	cell_total_sigma_dist.resize(n_cell);
         cell_total_dist.resize(n_cell);	
+        num_respon_source.resize(n_cell);	
     }
 
     void move_photon(Photon &phtn) {
@@ -255,12 +310,14 @@ private:
 	    Cell cell = mesh.get_cell(*k);
 	    const double* cell_dim = cell.get_node_array();
 	    if(x >= cell_dim[0] && x <= cell_dim[1] &&
-	       y >= cell_dim[1] && y <= cell_dim[2] &&
-	       z >= cell_dim[3] && z <= cell_dim[5]) {
+	       y >= cell_dim[2] && y <= cell_dim[3] &&
+	       z >= cell_dim[4] && z <= cell_dim[5]) {
 		return *k;
 	    } 
 	}
-	return tally_cells[0];
+    // Don't allow us to not find the correct cell
+    std::cout<<"ERROR: Possition non found -> "<<x<<" "<<y<<" "<<z<<std::endl;
+    exit(0);
     }
 
     // Check if the tally surface intersects the cell
@@ -302,8 +359,9 @@ private:
 
     vector<double> cell_total_sigma_dist;
     vector<double> cell_total_dist;
+    vector<int> num_respon_source;
 
-    uint32_t phtn_deck_size = 10000;
+    uint32_t phtn_deck_size = 100000;
     vector<double> start_x;
     vector<double> start_y;
     vector<double> start_z;
diff --git a/src/test/test_mesh.cc b/src/test/test_mesh.cc
index 7f22dd2..460a475 100644
--- a/src/test/test_mesh.cc
+++ b/src/test/test_mesh.cc
@@ -234,9 +234,9 @@ int main(int argc, char *argv[]) {
 	Mesh mesh(input, mpi_types, mpi_info, imc_p); // Create a mesh
         mesh.initialize_physical_properties(input); // Initialize the physical props (T)
 
-	Tally* tally = new Tally(1, 1e-6, 1e-6, 1e-6, mesh); // Tally for point_source.xml
+	Tally* tally = new Tally(0.99, 1e-6, 1e-6, 1e-6, mesh); // Tally for point_source.xml
 	
-    	imc_response_driver(mesh, imc_state, imc_p, mpi_types, mpi_info, tally, 50000);
+    	imc_response_driver(mesh, imc_state, imc_p, mpi_types, mpi_info, tally, 100000);
 
 	// PRINT OUT THE TALLY INFORMATION
     	cout << "\n\tTally energy for Regular: \t" << tally->get_regular_E() << endl;
diff --git a/src/write_silo.h b/src/write_silo.h
index 1a7b016..a2ebd32 100644
--- a/src/write_silo.h
+++ b/src/write_silo.h
@@ -90,6 +90,7 @@ void write_silo(const Mesh &mesh, const Sphere_Response &resp, const double &arg
   vector<double> T_r(n_xyz_cells, 0.0);
   vector<double> sig_a(n_xyz_cells, 0.0);
   vector<double> r_sig_a(n_xyz_cells, 0.0);
+  vector<double> r_src(n_xyz_cells, 0.0);
   vector<double> transport_time(n_xyz_cells, 0.0);
   vector<double> mpi_time(n_xyz_cells, 0.0);
   vector<int> grip_ID(n_xyz_cells, 0);
@@ -109,6 +110,7 @@ void write_silo(const Mesh &mesh, const Sphere_Response &resp, const double &arg
     sig_a[silo_index] = mesh.get_cell(i).get_op_a(0);
     if(resp.get_response_state()) {
         r_sig_a[silo_index] = resp.get_response(i);
+        r_src[silo_index] = resp.get_n_sourced(i);
     }
     transport_time[silo_index] = r_transport_time;
     mpi_time[silo_index] = r_mpi_time;
@@ -137,6 +139,9 @@ void write_silo(const Mesh &mesh, const Sphere_Response &resp, const double &arg
     MPI_Allreduce(MPI_IN_PLACE, &r_sig_a[0], n_xyz_cells, MPI_DOUBLE, MPI_SUM,
                   MPI_COMM_WORLD);
 
+    // reduce to get sig_a across all ranks
+    MPI_Allreduce(MPI_IN_PLACE, &r_src[0], n_xyz_cells, MPI_DOUBLE, MPI_SUM,
+                  MPI_COMM_WORLD);
 
     // reduce to get transport runtime from all ranks
     MPI_Allreduce(MPI_IN_PLACE, &transport_time[0], n_xyz_cells, MPI_DOUBLE,
@@ -259,6 +264,14 @@ void write_silo(const Mesh &mesh, const Sphere_Response &resp, const double &arg
     DBPutQuadvar1(dbfile, "r_sig_a", "quadmesh", &r_sig_a[0], cell_dims, ndims, NULL, 0,
                   DB_DOUBLE, DB_ZONECENT, Tr_optlist);
 
+    // ture scalar field
+    DBoptlist *r_src_optlist = DBMakeOptlist(2);
+    DBAddOption(r_src_optlist, DBOPT_UNITS, (void *)"#");
+    DBAddOption(r_src_optlist, DBOPT_DTIME, &time);
+    DBPutQuadvar1(dbfile, "r_src", "quadmesh", &r_src[0], cell_dims, ndims, NULL, 0,
+                  DB_DOUBLE, DB_ZONECENT, Tr_optlist);
+
+
 
 
     // free option lists
@@ -267,6 +280,7 @@ void write_silo(const Mesh &mesh, const Sphere_Response &resp, const double &arg
     DBFreeOptlist(Tr_optlist);
     DBFreeOptlist(sig_a_optlist);
     DBFreeOptlist(r_sig_a_optlist);
+    DBFreeOptlist(r_src_optlist);
 
     // free data
     delete[] cell_dims;
